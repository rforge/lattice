\documentclass[10pt]{article}

\title{Displaying model fits in lattice plots}
\author{Deepayan Sarkar}
\date{}

\usepackage[text={6.5in,8.5in},centering]{geometry}
\usepackage{bm}
\usepackage[round]{natbib}
\usepackage{alltt}
\usepackage{graphicx}
\usepackage{url}
\usepackage{hyperref}
\usepackage{Sweave}
\setkeys{Gin}{width=0.98\textwidth}

\newcommand{\fixme}[1]{\emph{\small \textbf{#1}}}
\newcommand{\R}{\textsf{R}}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\lattice}{\code{lattice}}
\newcommand{\Rpackage}[1]{\code{#1}}
\newcommand{\Rfunction}[1]{\code{#1()}}
\newcommand{\class}[1]{\textit{``#1''}}


\newcommand{\dontshow}[1]{}

\newtheorem{exercise}{Exercise}
\newenvironment{solution}{}{}


\begin{document}
\maketitle

\raggedright


\SweaveOpts{keep.source=TRUE,pdf=TRUE,eps=FALSE,width=9,prefix.string=figs/modelfit}


<<echo=FALSE,results=hide>>=
library(lattice)
lattice.options(default.theme = standard.theme("pdf", color = TRUE),
                panel.error = NULL)
options(width = 70, 
        str = list(strict.width = 'cut', 
                   digits.d = 3, vec.len = 3), 
        continue = '  ')
@ 



\lattice\ is an add-on package that implements Trellis graphics
(originally developed for \textsf{S} and \textsf{S-PLUS}) in \R.  It
is a powerful and elegant high-level data visualization system, with
an emphasis on multivariate data, that is sufficient for typical
graphics needs, and is also flexible enough to handle most nonstandard
requirements.  
\\

This document discusses the common situation where we want to augment
a raw data plot with a model fit.  We will use two illustrative
examples.  
\\

The first one is the \code{Oxboys} dataset from the \Rpackage{nlme}
package, which records the growth (height) over time of 26 boys from
Oxford.  Each boy had his height measured on 9 occasions.
<<>>=  
data(Oxboys, package = "nlme")
head(Oxboys)
@ 
%
A simple Trellis plot of the data can be obtained by
<<>>=  
xyplot(height ~ age | Subject, data = Oxboys, 
       strip = FALSE, aspect = "xy", pch = 16,
       xlab = "Standardized age", ylab = "Height (cm)")
@ 
%
Each panel represents one subject.  As the subject identifiers are
uninformative, the usual strips on top of each panel is omitted.
<<echo=FALSE,fig=TRUE,width=9,height=6>>=
plot(trellis.last.object())
@ 
%
Our objective will be to fit growth curves (possibly nonlinear) to the
data and superpose them on the plot.
\\

~~~~The second example is the \code{Gcsemv} dataset from the
\Rpackage{mlmRev} package. This dataset records the GCSE exam scores
in a science subject for 1905 students.  The marks in two components
(course work and written paper) are recorded separately.  We are
interested in modeling the expected written score based on course work
score, taking into account the gender of the student.
<<>>=  
data(Gcsemv, package = "mlmRev")
head(Gcsemv)
@ 
%
A plot of the raw data is produced by
<<>>=  
xyplot(written ~ course | gender, data = Gcsemv, 
       xlab = "Coursework score", 
       ylab = "Written exam score")
@ 
<<echo=FALSE,fig=TRUE,width=9,height=6>>=
plot(trellis.last.object())
@ 




\section*{Adding to a Lattice display}

In both examples, we wish to add to the basic plot of the raw data.
In traditional \R\ graphics, one is encouraged to incrementally add
components to a plot.  The analogue in Lattice graphics is to write
panel functions.
\\


\subsection*{Understanding panel functions}

The idea of panel functions may seem intimidating to beginners, but
actually they are quite simple.  As the name suggests, panel functions
are simply \R\ functions (!).  They are responsible for drawing the
graphical content inside panels.  They get executed once for every
panel, with the data specific to that panel supplied as arguments.
Every high level function has a default panel function, e.g.,
\Rfunction{xyplot} has default panel function
\Rfunction{panel.xyplot}.  Thus, the code that produced the GCSE score
plot above is equivalent to
<<eval=FALSE>>=    
xyplot(written ~ course | gender, data = Gcsemv, 
       xlab = "Coursework score", 
       ylab = "Written exam score",
       panel = panel.xyplot)
@ 
%
Here ``\code{panel.xyplot}'' is a (predefined) symbol whose value is a
function.  But creating new functions is not at all difficult in \R.
Making things a little more complicated, but keeping the results
unchanged, we can explicitly define a new inline function, which
simply calls \Rfunction{panel.xyplot} with exactly the arguments given
to it.
<<eval=FALSE>>=    
xyplot(written ~ course | gender, data = Gcsemv, 
       xlab = "Coursework score", 
       ylab = "Written exam score",
       panel = function(...) {
           panel.xyplot(...)
       })
@ 
%
Now, to do anything interesting with the data, we need to get access
to the raw data for each panel.  For each high-level
\Rpackage{lattice} function, such as \Rfunction{xyplot}, the raw data
is passed to the panel function as specific arguments (which may
depend on the high-level function).  Looking at the help page for
\Rfunction{panel.xyplot} tells us that for our example these arguments
are \code{x} and \code{y}.  Thus, another equivalent way to create the
plot above is
<<eval=FALSE>>=    
xyplot(written ~ course | gender, data = Gcsemv, 
       xlab = "Coursework score", 
       ylab = "Written exam score",
       panel = function(x, y, ...) {
           panel.xyplot(x, y, ...)
       })
@ 
%
Here, we finally have access to the panel-specific data, but instead
of doing anything with it (yet), we have simply called
\Rfunction{panel.xyplot} with it.  Although the sequence of calls so
far produce identical results, it is important to understand the
concepts that have been introduced to appreciate the next example.


\subsection*{A nontrivial panel function}


Now that we have access to the data inside the inline panel function
we are defining, we can use it to add further elements to the plot.
In the following, we add several elements: a reference grid (which
does not really depend on the data), a loess fit, and marginal
``rugs'' indicating cases where one (but not both) of the score
components were missing.
<<>>=    
xyplot(written ~ course | gender, data = Gcsemv, 
       xlab = "Coursework score", 
       ylab = "Written exam score",
       panel = function(x, y, ...) {
           panel.grid(h = -1, v = -1)
           panel.xyplot(x, y, ...)
           panel.loess(x, y, ..., col = "black")
           panel.rug(x = x[is.na(y)], 
                     y = y[is.na(x)])
       })
@ 
%
Here the individual elements are added by the component functions
\Rfunction{panel.grid}, \Rfunction{panel.loess}, \Rfunction{rug},
etc., which all produce some form of graphical output, based on
arguments supplied to it.  Together they define a \emph{procedure} for
plotting the data in a panel, encapsulated in the ``panel function''.
Notice that we also needed to include a call to
\Rfunction{panel.xyplot}, as without it the raw data would not have
been plotted.  Also notice that \Rfunction{panel.grid} is called
\emph{before} it, so that the grid is rendered \emph{below} the
points.  Having the panel function control the display completely
allows this kind of fine control.
<<echo=FALSE,fig=TRUE,width=9,height=6>>=
plot(trellis.last.object())
@ 


\subsection*{Passing arguments through \dots}

We have used a \code{\dots} construct in all the panel functions
defined above; it is now time to understand how it works.  The idea is
fairly simple.  Functions normally have zero, one, or more named
arguments.  It can also optionally have a special \code{\dots}
argument.  When such a function is called, they can be supplied
further arguments not matching the named arguments.  These arguments
can then be passed on to other functions called by it, where it may
match a named argument.  The first explicit use of an inline function
above provides an example of this:
<<eval=FALSE>>=
       panel = function(...) {
           panel.xyplot(...)
       })
@ 
%
The \code{panel} function is called with arguments named \code{x} and
\code{y}.  Although \code{panel} itself does not recognize these
names, it will dutifully pass them on to \Rfunction{panel.xyplot},
which \emph{does} recognize them.


\subsection*{Simplifying the call}

\Rfunction{panel.xyplot} has only two compulsory arguments (\code{x}
and \code{y}), but it has quite a few optional arguments (with
appropriate default values) which can modify its behaviour in various
ways.  In particular, two of its arguments, \code{grid} and
\code{type}, can be used to make it include a background grid and a
fitted loess smooth respectively (see \code{help(panel.xyplot)} for
details).  For example, we may write
<<>>=
xyplot(written ~ course | gender, data = Gcsemv, 
       panel = function(x, y) {
           panel.xyplot(x, y, grid = TRUE,
                        type = c("p", "smooth"),
                        col.line = "black")
       })
@ 
%
A useful observation is that this is equivalent to 
<<>>=
xyplot(written ~ course | gender, data = Gcsemv, 
       grid = TRUE, type = c("p", "spline"), col.line = "black",
       panel = function(x, y, ...) {
           panel.xyplot(x, y, ...)
       })
@ 
%
This is a consequence of how \Rfunction{xyplot} itself is designed; it
has a \code{\dots} argument, and arguments that are not otherwise
recognized by \Rfunction{xyplot} are passed on to the panel function.
Notice how the panel function in the last plot is similar to our
initial panel function examples that did nothing special.  


is equivalent to 
<<>>=
xyplot(written ~ course | gender, data = Gcsemv, grid = TRUE, 
       type = c("p", "spline"), col.line = "black")
@ 


<<echo=FALSE,fig=TRUE,width=9,height=6>>=
plot(trellis.last.object())
@ 






  \subsection*{Passing arguments to panel functions}
  \begin{itemize}
  \item Requires knowledge of arguments supported by panel function
  \item Each high-level function has a corresponding \textit{default}
    panel function, named as ``\code{panel.}'' followed by the
    function name.  For example,
    \begin{itemize}
    \item \Rfunction{histogram} has panel function \code{panel.histogram}
    \item \Rfunction{dotplot} has panel function \code{panel.dotplot}
    \end{itemize}
  \item Most have useful arguments that support common variants
  \end{itemize}


  

  \subsection*{Back to regression lines}
  \begin{itemize}
  \item \code{Oxboys}: model height on age
    \[
    \bm{y}_{ij} = \mu + \bm{b}_i + \bm{x}_{ij} + \bm{x}_{ij}^2 + \varepsilon_{ij}
    \]
  \item Mixed effect model that can be fit with \code{lme4}
<<results=hide>>=    
library(lme4)
fm.poly <- 
    lmer(height ~ poly(age, 2) + (1 | Subject), 
         data = Oxboys)
@ 
% <<>>=
% fm.poly
% @ 

  \item Goal: plot of data with fitted curve superposed 
  \end{itemize}




  % \subsection*{}
<<echo=FALSE>>=  
xyplot(height + fitted(fm.poly) ~ age | Subject, 
       data = Oxboys, strip = FALSE, aspect = "xy", pch = 16, lwd = 2,
       type = c("p", "l"), distribute.type = TRUE,
       xlab = "Standardized age", ylab = "Height (cm)")
@ 
<<echo=FALSE,fig=TRUE,width=9,height=6>>=
plot(trellis.last.object())
@ 




  % \subsection*{}
<<>>=  
xyplot(height ~ age | Subject, 
       data = Oxboys, strip = FALSE, aspect = "xy",
       type = "p", pch = 16,
       xlab = "Standardized age", ylab = "Height (cm)")
@ 
<<echo=FALSE,fig=TRUE,width=9,height=6>>=
plot(trellis.last.object())
@ 




  % \subsection*{}
<<>>=  
xyplot(fitted(fm.poly) ~ age | Subject, 
       data = Oxboys, strip = FALSE, aspect = "xy",
       type = "l", lwd = 2,
       xlab = "Standardized age", ylab = "Height (cm)")
@ 
<<echo=FALSE,fig=TRUE,width=9,height=6>>=
plot(trellis.last.object())
@ 






  % \subsection*{}
<<>>=  
xyplot(height + fitted(fm.poly) ~ age | Subject,
       data = Oxboys, strip = FALSE, aspect = "xy", pch = 16,
       lwd = 2, type = c("p", "l"), distribute.type = TRUE,
       xlab = "Standardized age", ylab = "Height (cm)")
@ 
<<echo=FALSE,fig=TRUE,width=9,height=6>>=
plot(trellis.last.object())
@ 




<<echo=FALSE,results=hide>>=
data(Gcsemv, package = "mlmRev")
@ 




  \subsection*{GCSE exam scores}
  \begin{itemize}
  \item \code{Gcsemv}: model written score by coursework and gender
  \item A similar approach does not work as well
    \begin{itemize}
    \item $x$ values are not ordered
    \item missing values are omitted from fitted model
    \end{itemize}
  \end{itemize}




  % \subsection*{}
<<>>=  
fm <- lm(written ~ course + I(course^2) + gender, Gcsemv)
xyplot(written + fitted(fm) ~ course | gender, 
       data = subset(Gcsemv, !(is.na(written) | is.na(course))),
       type = c("p", "l"), distribute.type = TRUE)

@ 
<<echo=FALSE,fig=TRUE,width=9,height=6>>=
plot(trellis.last.object())
@ 




  %\subsection*{GCSE exam scores}
  \begin{itemize}
  \item Built-in solution: Simple Linear Regression in each panel
  \end{itemize}
<<>>=  
xyplot(written ~ course | gender, Gcsemv, 
       type = c("p", "r"), col.line = "black")
@ 
<<echo=FALSE,fig=TRUE,width=9,height=6>>=
plot(trellis.last.object())
@ 





  \subsection*{GCSE exam scores}
  \begin{itemize}
  \item More complex models need a little more work
  \item Consider three models:
<<>>=
fm0 <- lm(written ~ course, Gcsemv)
fm1 <- lm(written ~ course + gender, Gcsemv)
fm2 <- lm(written ~ course * gender, Gcsemv)
@
  \item Goal: compare \code{fm2} and \code{fm1} with \code{fm0}
  \end{itemize}



<<echo=FALSE>>=

grid <-
    expand.grid(course = do.breaks(range(Gcsemv$course, finite = TRUE), 30),
                gender = unique(Gcsemv$gender))

fm0.pred <- cbind(grid, written = predict(fm0, newdata = grid))
fm1.pred <- cbind(grid, written = predict(fm1, newdata = grid))
fm2.pred <- cbind(grid, written = predict(fm2, newdata = grid))

orig <- Gcsemv[c("course", "gender", "written")]

combined <-
    make.groups(original = orig, 
                fm0 = fm0.pred,
                fm2 = fm2.pred)

xyplot(written ~ course | gender, combined, groups = which,
       type = c("p", "l", "l"), distribute.type = TRUE)

@ 
<<echo=FALSE,fig=TRUE,width=9,height=6>>=
plot(trellis.last.object())
@ 





  %% \subsection*{One Approach}
  \begin{itemize}
  \item Solution: evaluate fits separately and combine
  %% \item Generalizes to more models, other types of models
<<>>=

course.rng <- range(Gcsemv$course, finite = TRUE)
grid <-
    expand.grid(course = do.breaks(course.rng, 30),
                gender = unique(Gcsemv$gender))

fm0.pred <- 
    cbind(grid, 
          written = predict(fm0, newdata = grid))
fm1.pred <- 
    cbind(grid, 
          written = predict(fm1, newdata = grid))
fm2.pred <- 
    cbind(grid, 
          written = predict(fm2, newdata = grid))

orig <- Gcsemv[c("course", "gender", "written")]
@
  \end{itemize}



<<>>=

str(orig)
str(fm0.pred)

@



  % \subsection*{Approach: evaluate fits separately and combine}
<<>>=

combined <-
    make.groups(original = orig, 
                fm0 = fm0.pred,
                fm2 = fm2.pred)

str(combined)

@





<<>>=
xyplot(written ~ course | gender, 
       data = combined, groups = which,
       type = c("p", "l", "l"), distribute.type = TRUE)
@ 
<<echo=FALSE,fig=TRUE,width=9,height=6>>=
plot(trellis.last.object())
@ 





% 
%   \subsection*{}
%   \begin{itemize}
%   \item Generalizes to
%     \begin{itemize}
%     \item More than two fitted models
%     \item Non-linear models
%     \end{itemize}
%   \end{itemize}
% 



\subsection{Summary}


\paragraph{Take home message}
\begin{itemize}
\item Panel functions provide finest level of control
\item Built-in panel functions are also powerful
  \begin{itemize}
  \item Easily taken advantage of using argument passing
  \item Requires knowledge of arguments (read documentation!)
  \item Special function \Rfunction{panel.superpose} useful for
    grouping
  \end{itemize}
\end{itemize}




\subsection*{Session information}

<<echo=FALSE,results=tex>>=
toLatex(sessionInfo())
@ 



\bibliography{references}
\bibliographystyle{abbrvnat}


\end{document}
