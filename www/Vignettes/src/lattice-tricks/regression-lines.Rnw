\documentclass[10pt]{article}

\title{Displaying model fits in Lattice plots}
\author{Deepayan Sarkar}
\date{}

\usepackage[text={6.5in,8.5in},centering]{geometry}
\usepackage{bm}
\usepackage[round]{natbib}
\usepackage{alltt}
\usepackage{graphicx}
\usepackage{url}
\usepackage{hyperref}
\usepackage{Sweave}
\setkeys{Gin}{width=0.98\textwidth}

\newcommand{\fixme}[1]{\emph{\small \textbf{#1}}}
\newcommand{\R}{\textsf{R}}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\lattice}{\code{lattice}}
\newcommand{\Rpackage}[1]{\code{#1}}
\newcommand{\Rfunction}[1]{\code{#1()}}
\newcommand{\class}[1]{\textit{``#1''}}


\newcommand{\dontshow}[1]{}

\newtheorem{exercise}{Exercise}
\newenvironment{solution}{}{}


\begin{document}
\maketitle

\raggedright


\SweaveOpts{keep.source=TRUE,pdf=TRUE,eps=FALSE,width=9,prefix.string=figs/modelfit}


<<echo=FALSE,results=hide>>=
library(lattice)
lattice.options(default.theme = standard.theme("pdf", color = TRUE),
                panel.error = NULL)
options(width = 70,
        str = list(strict.width = 'cut',
                   digits.d = 3, vec.len = 3),
        continue = '  ')
@



\lattice\ is an add-on package that implements Trellis graphics
(originally developed for \textsf{S} and \textsf{S-PLUS}) in \R.  It
is a powerful and elegant high-level data visualization system, with
an emphasis on multivariate data, that is sufficient for typical
graphics needs, and is also flexible enough to handle most nonstandard
requirements.
\\

This document discusses the common situation where we want to augment
a raw data plot with a model fit.  We will use two illustrative
examples.  We assume that the reader is familiar with the basic ideas
related to model-fiting in \R, and in particular the use of
\Rfunction{summary}, \Rfunction{fitted}, \Rfunction{predict}, and
related methods.
\\

The first one is the \code{Oxboys} dataset from the \Rpackage{nlme}
package, which records the growth (height) over time of 26 boys from
Oxford.  Each boy had his height measured on 9 occasions.
<<>>=
data(Oxboys, package = "nlme")
head(Oxboys, 20)
@
%

\newpage

A simple Trellis plot of the data can be obtained by
<<>>=
xyplot(height ~ age | Subject, data = Oxboys,
       strip = FALSE, aspect = "xy", pch = 16,
       xlab = "Standardized age", ylab = "Height (cm)")
@
%
Each panel represents one subject.  As the subject identifiers are
uninformative, the usual strips on top of each panel is omitted.
<<echo=FALSE,fig=TRUE,width=9,height=6>>=
plot(trellis.last.object())
@
%
Our objective will be to fit growth curves (possibly nonlinear) to the
data and superpose them on the plot.
\\

\newpage

The second example is the \code{Gcsemv} dataset from the
\Rpackage{mlmRev} package. This dataset records the GCSE exam scores
in a science subject for 1905 students.  The marks in two components
(course work and written paper) are recorded separately.  We are
interested in modeling the expected written score based on course work
score, taking into account the gender of the student.
<<>>=
data(Gcsemv, package = "mlmRev")
head(Gcsemv)
@
%
A plot of the raw data is produced by
<<>>=
xyplot(written ~ course | gender, data = Gcsemv,
       xlab = "Coursework score",
       ylab = "Written exam score")
@
<<echo=FALSE,fig=TRUE,width=9,height=5>>=
plot(trellis.last.object())
@


\newpage

\section*{Adding to a Lattice display}

In both examples, we wish to add to the basic plot of the raw data.
In traditional \R\ graphics, one is encouraged to incrementally add
components to a plot.  The analogue in Lattice graphics is to write
panel functions.
\\


\subsection*{Understanding panel functions}

The idea of panel functions may seem intimidating to beginners, but
actually they are quite simple.  As the name suggests, panel functions
are simply \R\ functions (!).  They are responsible for drawing the
graphical content inside panels.  They get executed once for every
panel, with the data specific to that panel supplied as arguments.
Every high level function has a default panel function, e.g.,
\Rfunction{xyplot} has default panel function
\Rfunction{panel.xyplot}.  Thus, the code that produced the GCSE score
plot above is equivalent to
<<eval=FALSE>>=
xyplot(written ~ course | gender, data = Gcsemv,
       xlab = "Coursework score",
       ylab = "Written exam score",
       panel = panel.xyplot)
@
%
Here ``\code{panel.xyplot}'' is a (predefined) symbol whose value is a
function.  But creating new functions is not at all difficult in \R.
Making things a little more complicated, but keeping the results
unchanged, we can explicitly define a new inline function, which
simply calls \Rfunction{panel.xyplot} with exactly the arguments given
to it.
<<eval=FALSE>>=
xyplot(written ~ course | gender, data = Gcsemv,
       xlab = "Coursework score",
       ylab = "Written exam score",
       panel = function(...) {
           panel.xyplot(...)
       })
@
%
Now, to do anything interesting with the data, we need to get access
to the raw data for each panel.  For each high-level
\Rpackage{lattice} function, such as \Rfunction{xyplot}, the raw data
is passed to the panel function as specific arguments (which may
depend on the high-level function).  Looking at the help page for
\Rfunction{panel.xyplot} tells us that for our example these arguments
are \code{x} and \code{y}.  Thus, another equivalent way to create the
plot above is
<<eval=FALSE>>=
xyplot(written ~ course | gender, data = Gcsemv,
       xlab = "Coursework score",
       ylab = "Written exam score",
       panel = function(x, y, ...) {
           panel.xyplot(x, y, ...)
       })
@
%
Here, we finally have access to the panel-specific data, but instead
of doing anything with it (yet), we have simply called
\Rfunction{panel.xyplot} with it.  Although the sequence of calls so
far produce identical results, it is important to understand the
concepts that have been introduced to appreciate the next example.

\newpage

\subsection*{A nontrivial panel function}


Now that we have access to the data inside the inline panel function
we are defining, we can use it to add further elements to the plot.
In the following example, we add several elements: a reference grid
(which does not really depend on the data), a loess fit, and marginal
``rugs'' indicating cases where one (but not both) of the score
components are missing.
<<>>=
xyplot(written ~ course | gender, data = Gcsemv,
       xlab = "Coursework score",
       ylab = "Written exam score",
       panel = function(x, y, ...) {
           panel.grid(h = -1, v = -1)
           panel.xyplot(x, y, ...)
           panel.loess(x, y, ..., col = "black")
           panel.rug(x = x[is.na(y)],
                     y = y[is.na(x)])
       })
@
%
Here the individual elements are added by the component functions
\Rfunction{panel.grid}, \Rfunction{panel.loess},
\Rfunction{panel.rug}, etc., which all produce some form of graphical
output, based on arguments supplied to it.  Together they define a
\emph{procedure} for plotting the data in a panel, encapsulated in the
``panel function''.  Notice that we also needed to include a call to
\Rfunction{panel.xyplot}, as without it the raw data would not have
been plotted.  Also notice that \Rfunction{panel.grid} is called
\emph{before} it, so that the grid is rendered \emph{below} the
points.  Having the panel function control the display completely
allows this kind of fine control.

\vfill

<<echo=FALSE,fig=TRUE,width=9,height=5>>=
plot(trellis.last.object())
@

\newpage

\subsection*{Passing arguments through the \code{\dots} argument}

We have used a \code{\dots} construct in all the panel functions
defined above; it is now time to understand how it works.  The idea is
fairly simple.  Functions normally have zero, one, or more named
arguments.  It can also optionally have a special \code{\dots}
argument.  When such a function is called, they can be supplied
further arguments not matching the named arguments.  These arguments
can then be passed on to other functions called by it, where it may
match a named argument.  The first explicit use of an inline function
above provides an example of this:
\begin{Schunk}
\begin{Sinput}
       panel = function(...) {
           panel.xyplot(...)
       }
\end{Sinput}
\end{Schunk}
%
The \code{panel} function is called with arguments named \code{x} and
\code{y}.  Although \code{panel} itself does not recognize these
names, it will dutifully pass them on to \Rfunction{panel.xyplot},
which \emph{does} recognize them.


\subsection*{Using optional features of predefined panel functions}

\Rfunction{panel.xyplot} has only two compulsory arguments (\code{x}
and \code{y}), but it has quite a few optional arguments (with
appropriate default values) which can modify its behaviour in various
ways.  In particular, two of its arguments, \code{grid} and
\code{type}, can be used to make it include a background grid and a
fitted loess smooth respectively (see \code{help(panel.xyplot)} for
details).  For example, we may write
<<>>=
xyplot(written ~ course | gender, data = Gcsemv,
       panel = function(x, y) {
           panel.xyplot(x, y, grid = TRUE,
                        type = c("p", "smooth"),
                        col.line = "black")
       })
@
%

\vfill

<<echo=FALSE,fig=TRUE,width=9,height=5>>=
plot(trellis.last.object())
@

\newpage


\subsection*{Simplifying the call}


A useful observation is that this is equivalent to
<<>>=
xyplot(written ~ course | gender, data = Gcsemv,
       grid = TRUE, type = c("p", "smooth"), col.line = "black",
       panel = function(x, y, ...) {
           panel.xyplot(x, y, ...)
       })
@
%
This is a consequence of how \Rfunction{xyplot} itself is designed.
It has a \code{\dots} argument, which allows arbitrary additional
arguments to be supplied to it.  Arguments that are not recognized by
\Rfunction{xyplot} are passed on to the panel function.  Notice how
the panel function in the last plot is similar to our initial panel
function examples that did nothing special.  Following our earlier
arguments in reverse, we now see that the above is equivalent to
<<>>=
xyplot(written ~ course | gender, data = Gcsemv, grid = TRUE,
       type = c("p", "smooth"), col.line = "black",
       panel = panel.xyplot)
@
%
and hence also equivalent to
<<>>=
xyplot(written ~ course | gender, data = Gcsemv, grid = TRUE,
       type = c("p", "smooth"), col.line = "black")
@

The end result is thus produced by a call that looks quite simple, and
is quite close to the plot produced using the complicated panel
function above (except for the rugs).  Of course, this approach only
works for features already supported by the default panel function
(e.g., rugs are not supported by \Rfunction{panel.xyplot}, and thus
require an explicit panel function), and requires knowledge of what
features are available.  Still, most of the default panel functions
(named as ``\code{panel.}'' followed by the high-level function name)
do have optional arguments that implement the most common variants,
making this a quite useful approach.


\newpage


\section*{Back to regression lines}


Returning to our original question of how to add model fits, let us
next consider the \code{Oxboys} dataset.  We can of course add a loess
smooth to each panel as before, but we wish to stick to parametric
models for the remainder of this discussion.  The help page for
\Rfunction{panel.xyplot} tells us that \code{type="l"} will add a
linear regression line, so we can do

<<>>=
xyplot(height ~ age | Subject, data = Oxboys, strip = FALSE, 
       aspect = "xy", pch = 16, col.line = "black",
       grid = TRUE, type = c("p", "r"),
       xlab = "Standardized age", ylab = "Height (cm)")
@

\vfill

<<echo=FALSE,fig=TRUE,width=9,height=6>>=
plot(trellis.last.object())
@
%

\newpage

This does not seem completely appropriate though, as we expect growth
curves to be nonlinear.  Without thinking too much about \emph{what}
kind of nonlinearity would be appropriate, let us start out with a
simple quadratic model.  We can no longer get away without a panel
function, but we can use what we have already learned to come up with
<<>>=
xyplot(height ~ age | Subject, data = Oxboys, strip = FALSE, 
       aspect = "xy", pch = 16, grid = TRUE, 
       panel = function(x, y, ...) {
           panel.xyplot(x, y, ...)
           fm <- lm(y ~ poly(x, 2))
           panel.lines(x, fitted(fm), col.line = "black")
       },
       xlab = "Standardized age", ylab = "Height (cm)")
@
%
The specific model used here is not important, and we can replace the
call to \Rfunction{lm} inside the panel function with any other
suitable modeling function, provided of course that the model fit uses
only the data for that panel.

\vfill

<<echo=FALSE,fig=TRUE,width=9,height=6>>=
plot(trellis.last.object())
@

\newpage

\subsection*{Moving from panel-specific to more general models}

The approach taken so far is fundamentally limited in the sense that
it can only handle models that are fitted using the within-panel data
alone, because that is the only data available to the panel function.
In practice, we are often interested in more complex approaches that
model the full data.  To use such models in a \Rpackage{lattice} plot,
it is simplest to fit the model separately, \emph{before} attempting
to create the plot.
\\

~~~~Again, the particular model used is not important for our
purposes.  For illustration, we will use a mixed effect model that
generalizes the quadratic model used above, with common linear and
quadratic coefficients, and a subject-specific random intercept.
Formally, the model is given by 
\[
y_{ij} = \alpha_0 + b_i + \alpha_1 x_{ij} + \alpha_2 x_{ij}^2 + \varepsilon_{ij}
\]
where $i$ indexes subjects, $j$ indexes repeated measurements
(occasion) of a subject, $x_{ij}$ denotes (standardized) age, and
$y_{ij}$ denotes height.  The error terms $b_i$ and $\varepsilon_{ij}$
are assumed to be independent, with $b_i \sim N(0, \tau^2)$ and $b_i
\sim N(0, \sigma^2)$.  The parameters in the model are the
coefficients $\alpha_i$ and the variance terms $\tau^2$ and
$\sigma^2$.  The model can be fit using the \code{lme4} package as
follows.
<<>>=
library(lme4)
fm.mixed <- lmer(height ~ age + I(age^2) + (1 | Subject), data = Oxboys)
@
%
We might now proceed to view the estimates of the parameters and
related numerical quantities; for example, using
<<>>=
summary(fm.mixed)
@
%
However, our goal is simply to visually incorporate the fitted model
in the plot, and all we need for that is the \Rfunction{fitted} and
\Rfunction{predict} (which are closely related) methods for the
particular modeling method used.  The \Rfunction{fitted} function
returns the fitted values for the \emph{same} data that have been used
to fir the model.  The \Rfunction{predict} function can be used to
obtain the predicted values for a \emph{new} set of inputs.  If no new
data is provided, \Rfunction{predict} essentially behaves like
\Rfunction{fitted}.

\newpage


\subsection*{Fitted models in panel functions}

We now have the fitted model object \code{fm.mixed}, and we wish to
plot the fitted regression curve in each panel.  Two approaches are
possible.  We can make the fitted model available to the panel
function, and then use it as needed.  Alternatively, we can augment
our dataset with the necessary information \emph{before} plotting
anything.  We start with the first approach.
\\

~~~~We already know how to make the fitted model available to the
panel function: pass it in as an argument not recognized by
\Rfunction{xyplot}, and it will be passed on to the panel function.
Thus, we have

<<>>=
xyplot(height ~ age | Subject, data = Oxboys, fit = fm.mixed,
       strip = FALSE, aspect = "xy", pch = 16, grid = TRUE,
       panel = function(x, y, ..., fit) {
           panel.xyplot(x, y, ...)
           subj.coef <- coef(fit)$Subject[packet.number(), ]
           ypred <- with(subj.coef, 
                         `(Intercept)` + `age` * x + `I(age^2)` * x^2)
           panel.lines(x, ypred, col = "black")
       },
       xlab = "Standardized age", ylab = "Height (cm)")
@

\vfill

<<echo=FALSE,fig=TRUE,width=9,height=6>>=
plot(trellis.last.object())
@

\newpage

However, this seems unnecessarily complicated.  Partly this is due to
the use of the \Rfunction{lmer} function: as its fitted models do not
have a \Rfunction{predict} method (for legitimate reasons), we had to
manually construct the predictions using the result of
\Rfunction{coef}.  In general, for multipanel plots the current panel
will represent some subset of the full dataset, and we would need to
somehow figure out the relevant 


<<echo=FALSE>>=
xyplot(height + fitted(fm.mixed) ~ age | Subject,
       data = Oxboys, strip = FALSE, aspect = "xy", pch = 16, lwd = 2,
       type = c("p", "l"), distribute.type = TRUE,
       xlab = "Standardized age", ylab = "Height (cm)")
@
<<echo=FALSE,fig=TRUE,width=9,height=6>>=
plot(trellis.last.object())
@




  % \subsection*{}
<<>>=
xyplot(height ~ age | Subject,
       data = Oxboys, strip = FALSE, aspect = "xy",
       type = "p", pch = 16,
       xlab = "Standardized age", ylab = "Height (cm)")
@
<<echo=FALSE,fig=TRUE,width=9,height=6>>=
plot(trellis.last.object())
@




  % \subsection*{}
<<>>=
xyplot(fitted(fm.mixed) ~ age | Subject,
       data = Oxboys, strip = FALSE, aspect = "xy",
       type = "l", lwd = 2,
       xlab = "Standardized age", ylab = "Height (cm)")
@
<<echo=FALSE,fig=TRUE,width=9,height=6>>=
plot(trellis.last.object())
@






  % \subsection*{}
<<>>=
xyplot(height + fitted(fm.mixed) ~ age | Subject,
       data = Oxboys, strip = FALSE, aspect = "xy", pch = 16,
       lwd = 2, type = c("p", "l"), distribute.type = TRUE,
       xlab = "Standardized age", ylab = "Height (cm)")
@
<<echo=FALSE,fig=TRUE,width=9,height=6>>=
plot(trellis.last.object())
@




<<echo=FALSE,results=hide>>=
data(Gcsemv, package = "mlmRev")
@




  \subsection*{GCSE exam scores}
  \begin{itemize}
  \item \code{Gcsemv}: model written score by coursework and gender
  \item A similar approach does not work as well
    \begin{itemize}
    \item $x$ values are not ordered
    \item missing values are omitted from fitted model
    \end{itemize}
  \end{itemize}




  % \subsection*{}
<<>>=
fm <- lm(written ~ course + I(course^2) + gender, Gcsemv)
xyplot(written + fitted(fm) ~ course | gender,
       data = subset(Gcsemv, !(is.na(written) | is.na(course))),
       type = c("p", "l"), distribute.type = TRUE)
@
<<echo=FALSE,fig=TRUE,width=9,height=6>>=
plot(trellis.last.object())
@




  %\subsection*{GCSE exam scores}
  \begin{itemize}
  \item Built-in solution: Simple Linear Regression in each panel
  \end{itemize}
<<>>=
xyplot(written ~ course | gender, Gcsemv,
       type = c("p", "r"), col.line = "black")
@
<<echo=FALSE,fig=TRUE,width=9,height=6>>=
plot(trellis.last.object())
@





  \subsection*{GCSE exam scores}
  \begin{itemize}
  \item More complex models need a little more work
  \item Consider three models:
<<>>=
fm0 <- lm(written ~ course, Gcsemv)
fm1 <- lm(written ~ course + gender, Gcsemv)
fm2 <- lm(written ~ course * gender, Gcsemv)
@
  \item Goal: compare \code{fm2} and \code{fm1} with \code{fm0}
  \end{itemize}



<<echo=FALSE>>=

grid <-
    expand.grid(course = do.breaks(range(Gcsemv$course, finite = TRUE), 30),
                gender = unique(Gcsemv$gender))

fm0.pred <- cbind(grid, written = predict(fm0, newdata = grid))
fm1.pred <- cbind(grid, written = predict(fm1, newdata = grid))
fm2.pred <- cbind(grid, written = predict(fm2, newdata = grid))

orig <- Gcsemv[c("course", "gender", "written")]

combined <-
    make.groups(original = orig,
                fm0 = fm0.pred,
                fm2 = fm2.pred)

xyplot(written ~ course | gender, combined, groups = which,
       type = c("p", "l", "l"), distribute.type = TRUE)
@
<<echo=FALSE,fig=TRUE,width=9,height=6>>=
plot(trellis.last.object())
@





  %% \subsection*{One Approach}
  \begin{itemize}
  \item Solution: evaluate fits separately and combine
  %% \item Generalizes to more models, other types of models
<<>>=

course.rng <- range(Gcsemv$course, finite = TRUE)
grid <-
    expand.grid(course = do.breaks(course.rng, 30),
                gender = unique(Gcsemv$gender))

fm0.pred <-
    cbind(grid,
          written = predict(fm0, newdata = grid))
fm1.pred <-
    cbind(grid,
          written = predict(fm1, newdata = grid))
fm2.pred <-
    cbind(grid,
          written = predict(fm2, newdata = grid))

orig <- Gcsemv[c("course", "gender", "written")]
@
  \end{itemize}



<<>>=
str(orig)
str(fm0.pred)
@



  % \subsection*{Approach: evaluate fits separately and combine}
<<>>=
combined <-
    make.groups(original = orig,
                fm0 = fm0.pred,
                fm2 = fm2.pred)

str(combined)
@





<<>>=
xyplot(written ~ course | gender,
       data = combined, groups = which,
       type = c("p", "l", "l"), distribute.type = TRUE)
@
<<echo=FALSE,fig=TRUE,width=9,height=6>>=
plot(trellis.last.object())
@





%
%   \subsection*{}
%   \begin{itemize}
%   \item Generalizes to
%     \begin{itemize}
%     \item More than two fitted models
%     \item Non-linear models
%     \end{itemize}
%   \end{itemize}
%



\subsection{Summary}


\paragraph{Take home message}
\begin{itemize}
\item Panel functions provide finest level of control
\item Built-in panel functions are also powerful
  \begin{itemize}
  \item Easily taken advantage of using argument passing
  \item Requires knowledge of arguments (read documentation!)
  \item Special function \Rfunction{panel.superpose} useful for
    grouping
  \end{itemize}
\end{itemize}




\subsection*{Session information}

<<echo=FALSE,results=tex>>=
toLatex(sessionInfo())
@



\bibliography{references}
\bibliographystyle{abbrvnat}


\end{document}
